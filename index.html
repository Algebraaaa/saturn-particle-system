<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>粒子土星</title>
    
    <link rel="stylesheet" href="css/styles.css">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <video class="input_video"></video>
    
    <!-- 作者跳转按钮 -->
    <a id="author-btn" href="https://github.com/Algebraaaa" target="_blank">By Jay</a>

    <div id="fps-counter">物理引擎: 极致模式 | 环境: 太阳系模拟</div>

    <div id="loading">
        正在构建百万粒子与行星数据...
    </div>

    <div id="ui-layer">
        <div class="glass-panel">
            <h1>土星</h1>
            <div class="status-text">
                数据流状态: <span id="status-indicator" class="highlight">待机</span>
                <br><br>
                > 开普勒轨道: 运行中<br>
                > 粒子总数: 120万+<br>
                > 背景环境: 行星已加载
            </div>
        </div>
    </div>

    <div id="controls">
        <button onclick="toggleFullScreen()">全屏沉浸体验</button>
    </div>

    <div id="canvas-container"></div>

    <!-- ===== 土星着色器 ===== -->
    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        attribute vec3 customColor;
        attribute float opacityAttr;
        attribute float orbitSpeed;
        attribute float isRing;
        attribute float aRandomId;
        
        varying vec3 vColor;
        varying float vDist;
        varying float vOpacity;
        varying float vScaleFactor;
        varying float vIsRing;
        
        uniform float uTime;
        uniform float uScale;
        uniform float uRotationX;
        
        mat2 rotate2d(float _angle){
            return mat2(cos(_angle),-sin(_angle),
                        sin(_angle),cos(_angle));
        }

        float hash(float n) { return fract(sin(n) * 43758.5453123); }

        void main() {
            float normScaleLOD = clamp((uScale - 0.15) / 2.35, 0.0, 1.0);
            float visibilityThreshold = 0.9 + pow(normScaleLOD, 1.2) * 0.1; 

            if (aRandomId > visibilityThreshold) {
                gl_Position = vec4(0.0);
                gl_PointSize = 0.0;
                return;
            }

            vec3 pos = position;

            if (isRing > 0.5) {
                float angleOffset = uTime * orbitSpeed * 0.2;
                vec2 rotatedXZ = rotate2d(angleOffset) * pos.xz;
                pos.x = rotatedXZ.x;
                pos.z = rotatedXZ.y;
            } else {
                float bodyAngle = uTime * 0.03;
                vec2 rotatedXZ = rotate2d(bodyAngle) * pos.xz;
                pos.x = rotatedXZ.x;
                pos.z = rotatedXZ.y;
            }

            float cx = cos(uRotationX);
            float sx = sin(uRotationX);
            float ry = pos.y * cx - pos.z * sx;
            float rz = pos.y * sx + pos.z * cx;
            pos.y = ry;
            pos.z = rz;

            vec4 mvPosition = modelViewMatrix * vec4(pos * uScale, 1.0);
            float dist = -mvPosition.z;
            vDist = dist;

            float chaosThreshold = 25.0; 
            if (dist < chaosThreshold && dist > 0.1) {
                float chaosIntensity = 1.0 - (dist / chaosThreshold);
                chaosIntensity = pow(chaosIntensity, 3.0);

                float highFreqTime = uTime * 40.0; 
                float noiseX = sin(highFreqTime + pos.x * 10.0) * hash(pos.y);
                float noiseY = cos(highFreqTime + pos.y * 10.0) * hash(pos.x);
                float noiseZ = sin(highFreqTime * 0.5) * hash(pos.z);
                
                vec3 noiseVec = vec3(noiseX, noiseY, noiseZ) * chaosIntensity * 3.0;
                mvPosition.xyz += noiseVec;
            }
            
            gl_Position = projectionMatrix * mvPosition;
            
            float pointSize = size * (350.0 / dist); 
            pointSize *= 0.55; 

            if (isRing < 0.5 && dist < 50.0) {
                 pointSize *= 0.8; 
            }

            gl_PointSize = clamp(pointSize, 0.0, 300.0);

            vColor = customColor;
            vOpacity = opacityAttr;
            vScaleFactor = uScale;
            vIsRing = isRing;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec3 vColor;
        varying float vDist;
        varying float vOpacity;
        varying float vScaleFactor;
        varying float vIsRing;
        
        void main() {
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;
            
            float glow = smoothstep(1.0, 0.4, r); 
            
            float t = clamp((vScaleFactor - 0.15) / 2.35, 0.0, 1.0);

            vec3 deepGold = vec3(0.35, 0.22, 0.05); 
            float colorMix = smoothstep(0.1, 0.9, t);
            vec3 baseColor = mix(deepGold, vColor, colorMix);

            float brightness = 0.2 + 1.0 * t; 

            float densityAlpha = 0.25 + 0.45 * smoothstep(0.0, 0.5, t);

            vec3 finalColor = baseColor * brightness;
            
            if (vDist < 40.0) {
                float closeMix = 1.0 - (vDist / 40.0);
                
                if (vIsRing < 0.5) {
                    vec3 deepTexture = pow(vColor, vec3(1.4)) * 1.5; 
                    finalColor = mix(finalColor, deepTexture, closeMix * 0.8);
                } else {
                    finalColor += vec3(0.15, 0.12, 0.1) * closeMix;
                }
            }

            float depthAlpha = 1.0;
            if (vDist < 10.0) depthAlpha = smoothstep(0.0, 10.0, vDist);

            float alpha = glow * vOpacity * densityAlpha * depthAlpha;
            
            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>

    <!-- ===== 星空着色器 ===== -->
    <script type="x-shader/x-vertex" id="starVertexShader">
        attribute float size;
        attribute vec3 customColor;
        varying vec3 vColor;
        uniform float uTime;

        void main() {
            vColor = customColor;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            float dist = -mvPosition.z;
            gl_PointSize = size * (1000.0 / dist); 
            gl_PointSize = clamp(gl_PointSize, 1.0, 8.0);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="starFragmentShader">
        varying vec3 vColor;
        uniform float uTime;
        
        float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
        
        void main() {
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            float r = dot(cxy, cxy);
            if (r > 1.0) discard;
            
            float noise = random(gl_FragCoord.xy);
            float twinkle = 0.7 + 0.3 * sin(uTime * 2.0 + noise * 10.0);
            
            float glow = 1.0 - r;
            glow = pow(glow, 1.5);
            
            gl_FragColor = vec4(vColor * twinkle, glow * 0.8);
        }
    </script>

    <!-- ===== 行星着色器 ===== -->
    <script type="x-shader/x-vertex" id="planetVertexShader">
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        
        void main() {
            vUv = uv;
            vNormal = normalize(normalMatrix * normal);
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            vViewPosition = -mvPosition.xyz;
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="planetFragmentShader">
        uniform vec3 color1;
        uniform vec3 color2;
        uniform float noiseScale;
        uniform vec3 lightDir;
        uniform float atmosphere;
        
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;

        float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
        
        float noise(vec2 st) {
            vec2 i = floor(st);
            vec2 f = fract(st);
            float a = random(i);
            float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0));
            float d = random(i + vec2(1.0, 1.0));
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }
        
        float fbm(vec2 st) {
            float value = 0.0;
            float amplitude = 0.5;
            for (int i = 0; i < 5; i++) {
                value += amplitude * noise(st);
                st *= 2.0;
                amplitude *= 0.5;
            }
            return value;
        }

        void main() {
            float n = fbm(vUv * noiseScale);
            vec3 albedo = mix(color1, color2, n);
            
            vec3 normal = normalize(vNormal);
            vec3 light = normalize(lightDir);
            float diff = max(dot(normal, light), 0.05);
            
            vec3 viewDir = normalize(vViewPosition);
            float fresnel = pow(1.0 - dot(viewDir, normal), 3.0);
            
            vec3 finalColor = albedo * diff + atmosphere * vec3(0.5, 0.6, 1.0) * fresnel;
            
            gl_FragColor = vec4(finalColor, 1.0);
        }
    </script>

    <!-- 模块化 JavaScript 脚本 -->
    <script src="js/shader-manager.js"></script>
    <script src="js/saturn.js"></script>
    <script src="js/starfield.js"></script>
    <script src="js/planets.js"></script>
    <script src="js/gesture-handler.js"></script>
    <script src="js/app.js"></script>

</body>
</html>